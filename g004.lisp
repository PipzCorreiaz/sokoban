;(in-package :user)

(defvar *mapa*)
(defvar *mapa-cantos*)
(defvar *todos-estados-gerados* (make-hash-table :test 'equal))

(compile-file "sokoban.lisp")
(load "sokoban")
(compile-file "procura.lisp")
(load "procura")
(compile-file "procuras.lisp")
(load "procuras")

(defun passos (caminho)
	(reverse (second (first (last caminho)))))



(defun objectivo (estado)
	(let* ((mapa *mapa*)
			(caixotes (first estado))
			(posicoes-certas 0))
	(dotimes (i (length caixotes))
		(dolist (p caixotes)
			(when (equal p (nth i (mapa-sokoban-destinos mapa)))
				(incf posicoes-certas))))
	(= posicoes-certas (length caixotes))))

(defun copy-estado (estado)
	(let ((copy (make-mapa-sokoban))
			;(mapa (first estado))
			(caixas (copy-list (first estado)))
			(pos (copy-list (second estado))))
		; (setf (mapa-sokoban-mapa copy) (copy-array (mapa-sokoban-mapa mapa)))
		; (setf (mapa-sokoban-destinos copy) (copy-list (mapa-sokoban-destinos mapa)))
		; (setf (mapa-sokoban-mapa-aux copy) (copy-array (mapa-sokoban-mapa-aux mapa)))
		; (setf (mapa-sokoban-nlinhas copy) (mapa-sokoban-nlinhas mapa))
		; (setf (mapa-sokoban-ncolunas copy) (mapa-sokoban-ncolunas mapa))
		(list caixas pos)))


(defun jogadas-validas3 (mapa ocupadas x y)
  (let ((res nil))
    (unless (or (aref mapa (1+ x) y) (aref ocupadas (1+ x) y) (aref mapa (1- x) y) (aref ocupadas (1- x) y))
    	(push (list (1+ x) y) res)
    	(push (list (1- x) y) res))
    (unless (or (aref mapa x (1+ y)) (aref ocupadas x (1+ y)) (aref mapa x (1- y)) (aref ocupadas x (1- y)))
    	(push (list x (1+ y)) res)
    	(push (list x (1- y)) res))
    res))

(defun destino? (destinos x y)
  	(member (list x y) destinos :test #'equalp))


(defun jogadas-validas4 (estado ocupadas x y)
  (let ((mapa (mapa-sokoban-mapa *mapa*))
        (destinos (mapa-sokoban-destinos *mapa*))
        (res nil)
        (ocupadinhas nil)
        (resultadinho nil))
    (unless (or (aref mapa (1+ x) y) (aref ocupadas (1+ x) y) (aref mapa (1- x) y) (aref ocupadas (1- x) y))
    	(setf ocupadinhas (copy-array ocupadas))
     	(setf (aref ocupadinhas x y) nil)
      	(setf resultadinho (jogadas-validas3 mapa ocupadinhas (1+ x) y))
      	(when (or (destino? destinos (1+ x) y) (>= (length resultadinho) 2))
    		(push (list (1- x) y) res))
       	(setf ocupadinhas (copy-array ocupadas))
     	(setf (aref ocupadinhas x y) nil)
      	(setf resultadinho (jogadas-validas3 mapa ocupadinhas (1- x) y))
      	(when (or (destino? destinos (1- x) y) (>= (length resultadinho) 2))
    		(push (list (1+ x) y) res)))
    (unless (or (aref mapa x (1+ y)) (aref ocupadas x (1+ y)) (aref mapa x (1- y)) (aref ocupadas x (1- y)))
      	(setf ocupadinhas (copy-array ocupadas))
     	(setf (aref ocupadinhas x y) nil)
      	(setf resultadinho (jogadas-validas3 mapa ocupadinhas x (1+ y)))
      	(when (or (destino? destinos x (1+ y)) (>= (length resultadinho) 2))
    		(push (list x (1- y)) res))
       	(setf ocupadinhas (copy-array ocupadas))
     	(setf (aref ocupadinhas x y) nil)
      	(setf resultadinho (jogadas-validas3 mapa ocupadinhas x (1- y)))
      	(when (or (destino? destinos x (1- y)) (>= (length resultadinho) 2))
    		(push (list x (1+ y)) res)))
    res))

(defun vertical-freeze-deadlock? (x y ocupadas)
  (let ((res nil))
    (when (destino? (mapa-sokoban-destinos *mapa*) x y)
      (return-from vertical-freeze-deadlock? nil))
    (setf res (or (casa-ocupada *mapa* (1+ x) y)
                  (casa-ocupada *mapa* (1- x) y)
                  (and (corner-deadlock? (list (1+ x) y))
                       (corner-deadlock? (list (1- x) y)))))
    (when (not res)
      (when (casa-preenchida ocupadas (1+ x) y)
        (setf res (horizontal-freeze-deadlock? (1+ x) y ocupadas)))
      (when (casa-preenchida ocupadas (1- x) y)
        (setf res (horizontal-freeze-deadlock? (1- x) y ocupadas))))
    res))

(defun horizontal-freeze-deadlock? (x y ocupadas)
  (let ((res nil))
    (when (destino? (mapa-sokoban-destinos *mapa*) x y)
      (return-from horizontal-freeze-deadlock? nil))
    (setf res (or (casa-ocupada *mapa* x (1+ y))
                  (casa-ocupada *mapa* x (1- y))
                  (and (corner-deadlock? (list x (1+ y)))
                       (corner-deadlock? (list x (1- y))))))
    (when (not res)
      (when (casa-preenchida ocupadas x (1+ y))
        (setf res (vertical-freeze-deadlock? x (1+ y) ocupadas)))
      (when (casa-preenchida ocupadas x (1- y))
        (setf res (vertical-freeze-deadlock? x (1- y) ocupadas))))
    res))

(defun freeze-deadlock? (posicao-atual proxima-posicao ocupadas)
  (let ((x (first proxima-posicao))
        (y (second proxima-posicao))
        (copia-ocupadas (copy-array ocupadas)))
    (setf (aref copia-ocupadas (first posicao-atual) (second posicao-atual)) nil)
    (and (horizontal-freeze-deadlock? x y copia-ocupadas)
         (vertical-freeze-deadlock? x y copia-ocupadas))))

(defun corner-deadlock? (posicao)
  (eql (casa-preenchida *mapa-cantos* (first posicao) (second posicao)) 'DL))



(defun operador (estado)
  (let* ((mapa *mapa*)
         (novo-estado nil)
         (proxima-posicao nil)
         (sucessores nil)
         (homem (first (second estado))))
    (dotimes (i (length (first estado)))
      (let ((caixa (nth i (first estado)))
            (caminho nil)
            (ocupadas (coloca-caixotes (limpa-mapa-aux mapa) (first estado))))
        (dolist (jogada (jogadas-validas3 (mapa-sokoban-mapa mapa) ocupadas (first caixa) (second caixa)))
          (when (ha-caminho mapa (first estado) (first homem) (second homem) (first jogada) (second jogada))
            (setf novo-estado (copy-estado estado))
            (setf proxima-posicao (list (+ (- (first caixa) (first jogada)) (first caixa))
                                        (+ (- (second caixa) (second jogada)) (second caixa))))
            (setf ocupadas (coloca-caixotes (limpa-mapa-aux mapa) (first estado)))
            (when (and (not (corner-deadlock? proxima-posicao)) (not (freeze-deadlock? caixa proxima-posicao ocupadas)))
              (setf (nth i (first novo-estado)) proxima-posicao)
              (when (not (gethash novo-estado *todos-estados-gerados*))
                (setf caminho (encontra-caminho mapa (first estado) (first homem) (second homem) (first jogada) (second jogada)))
                (setf caminho (reverse caminho))
                (push caixa caminho)
                (setf (second novo-estado) (nconc caminho (cdr (second novo-estado))))
                (setf (gethash novo-estado *todos-estados-gerados*) t)
                (setf sucessores (cons novo-estado sucessores))))))))
    sucessores))

(defun compara-estado (estado1 estado2)
  (equalp estado1 estado2))

(defun compara-posicoes-caixas (estado1 estado2)
  (equalp (car estado1) (car estado2)))


(defun casa-preenchida (mapa i j)
  (aref mapa i j))


(defun elimina-cantos (mapa)
  (let ((linhas (mapa-sokoban-nlinhas *mapa*))
        (colunas (mapa-sokoban-ncolunas *mapa*))
        (destinos (mapa-sokoban-destinos *mapa*))
        (novo-mapa (copy-array mapa)))
    (dotimes (i linhas novo-mapa)
      (dotimes (j colunas)
        (when (and (> i 0) (> j 0) (< j (- colunas 1)) (< i (- linhas 1)))
          (when (and (or (and (casa-preenchida mapa (1+ i) j) (casa-preenchida mapa i (1+ j)))
                         (and (casa-preenchida mapa (1- i) j) (casa-preenchida mapa i (1+ j)))
                         (and (casa-preenchida mapa (1+ i) j) (casa-preenchida mapa i (1- j)))
                         (and (casa-preenchida mapa (1- i) j) (casa-preenchida mapa i (1- j))))
                     (not (casa-preenchida mapa i j))
                     (not (destino? destinos i j)))
            (setf (aref novo-mapa i j) 'DL)))))))

(defun resolve-sokoban (filename tipo-procura)
  (let* ((estado-inicial (parse-ficheiro filename))
         (problema nil)
         (caminho nil))
    (setf *mapa* (first estado-inicial))
    (setf *mapa-cantos* (elimina-cantos (mapa-sokoban-mapa *mapa*)))
    (setf estado-inicial (cdr estado-inicial))
    (setf (gethash estado-inicial *todos-estados-gerados*) t)
    (setf (second estado-inicial) (list (second estado-inicial)))
    (setf problema (cria-problema estado-inicial
                                  (list #'operador)
                                  :objectivo? #'objectivo
                                  :heuristica #'h1-alt
                                  :estado= #'compara-estado))
    (setf caminho (first (procura problema tipo-procura)))
    (passos caminho)))


(defun remove-nth (lst index)
  (if (= index 0)
      (cdr lst)
      (cons (car lst) (remove-nth (cdr lst) (1- index)))))

