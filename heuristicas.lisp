;soma as distancias de cada caixa em linha recta ate ao destino mais perto
(defun h1 (estado)
  (let ((caixas (second estado))
        (destinos (copy-list (mapa-sokoban-destinos (first estado))))
        (dist-min 1000)
        (index-min nil)
        (index 0)
        (res 0))
    (dolist (caixa caixas)
      (dolist (destino destinos)
        (let ((dist (sqrt (+ (expt (- (first caixa)
                                      (first destino)) 2)
                             (expt (- (second caixa)
                                      (second destino)) 2)))))
          (when (< dist dist-min)
            (setf dist-min dist)
            (setf index-min index))
          (setf index (1+ index))))
      (setf res (+ res dist-min))
      (setf destinos (remove-nth destinos index-min))
      (setf dist-min 1000)
      (setf index-min nil)
      (setf index 0))
    res))


;soma as distancias de cada caixa dadas pelo encontra-caminho ate ao destino mais perto
(defun h2 (estado)
  (let ((caixas (second estado))
        (destinos (copy-list (mapa-sokoban-destinos (first estado))))
        (dist-min 1000)
        (index-min nil)
        (index 0)
        (res 0))
    (dolist (caixa caixas)
      (dolist (destino destinos)
        (let ((dist (length (encontra-caminho (first estado) caixas (first caixa) (second caixa) (first destino) (second destino)))))
          (when (= dist 0)
            (setf dist 999))
          (when (< dist dist-min)
            (setf dist-min dist)
            (setf index-min index))
          (setf index (1+ index))))
      (setf res (+ res dist-min))
      (setf destinos (remove-nth destinos index-min))
      (setf dist-min 1000)
      (setf index-min nil)
      (setf index 0))
    res))


;distancia mais curta da caixa dada pelo encontra-caminho ate ao destino mais perto
(defun h3 (estado)
  (let ((caixas (second estado))
        (destinos (mapa-sokoban-destinos (first estado)))
        (dist-min 1000))
    (dolist (caixa caixas)
      (dolist (destino destinos)
        (let ((dist (length (encontra-caminho (first estado) caixas (first caixa) (second caixa) (first destino) (second destino)))))
          (when (= dist 0)
            (setf dist 999))
          (when (< dist dist-min)
            (setf dist-min dist)))))
    dist-min))


;numero de caixas acessiveis pelo homem com caminho ate ao destino
(defun h4 (estado)
  (let* ((caixas (second estado))
         (destinos (mapa-sokoban-destinos (first estado)))
         (homem (first (third estado)))
         (mapa (mapa-sokoban-mapa (first estado)))
         (mapa-aux (mapa-sokoban-mapa-aux (first estado)))
         (ocupadas (coloca-caixotes mapa-aux caixas))
         (contador 0))
    (dolist (caixa caixas)
      (when (not (member caixa destinos :test #'equalp))
        (dolist (adjacente (jogadas-validas3 mapa ocupadas (first caixa) (second caixa)))
          (when (ha-caminho (first estado) caixas (first homem) (second homem) (first adjacente) (second adjacente))
            (block encontra-destinos
                   (dolist (destino destinos)
                     (when (ha-caminho (first estado) caixas (first caixa) (second caixa) (first destino) (second destino))
                       (return-from encontra-destinos (incf contador)))))))))
    (- 1000 contador)))


;conta as adjacentes das caixas
(defun h5 (estado)
  (let* ((caixas (second estado))
         (mapa (mapa-sokoban-mapa (first estado)))
         (ocupadas (coloca-caixotes (mapa-sokoban-mapa-aux (first estado)) caixas))
         (num-caixas (length caixas))
         (res 0))
    (dolist (caixa caixas)
      (setf res (+ res (length (jogadas-validas3 mapa ocupadas (first caixa) (second caixa))))))
    (- (* 4 num-caixas) res)))


;numero de caixas que tem caminho ate um destino
(defun h6 (estado)
  (let ((caixas (second estado))
        (destinos (mapa-sokoban-destinos (first estado)))
        (res 0))
    (dolist (caixa caixas)
      (block encontra-dest-acessivel
             (dolist (destino destinos)
               (when (ha-caminho (first estado) caixas (first caixa) (second caixa) (first destino) (second destino))
                 (incf res)
                 (return-from encontra-dest-acessivel)))))
    (- (length caixas) res)))
          
          
;numero de caixas acessiveis pelo homem
(defun h7 (estado)
  (let ((caixas (second estado))
        (homem (first (third estado)))
        (res 0))
    (dolist (caixa caixas)
      (when (ha-caminho (first estado) caixas (first homem) (second homem) (first caixa) (second caixa))
        (incf res)))
    (- (length caixas) res)))

(defun left (caixa)
  (list (car caixa) (1- (cadr caixa))))

(defun right (caixa)
  (list (car caixa) (1+ (cadr caixa))))

(defun down (caixa)
  (list (1+ (car caixa)) (cadr caixa)))

(defun up (caixa)
  (list (1- (car caixa)) (cadr caixa)))

(defun ocupada? (mapa pos)
  (aref mapa (car pos) (cadr pos)))


;heuristica ninja
(defun h8 (estado)
  (limpa-mapa-aux (car estado))
  (let* ((caixas (second estado))
         (mapa (mapa-sokoban-mapa (first estado)))
         (ocupadas (coloca-caixotes (mapa-sokoban-mapa-aux (first estado)) caixas))
         (destinos (mapa-sokoban-destinos (first estado)))
         (res 0))
    (print caixas)
    (dolist (caixa caixas)
      (let ((l (left caixa))
            (r (right caixa))
            (d (down caixa))
            (u (up caixa))
            (caixa-e-destino? (member caixa destinos :test #'equalp)))
              ;CASO 1
        (cond (caixa-e-destino?
                (print "e destino")
                (setf res (+ res 0)))
          ; ((and caixa-e-destino?
          ;           (or (ocupada? mapa r)
          ;               (ocupada? mapa l))
          ;           (or (ocupada? mapa d)
          ;               (ocupada? mapa u)))
          ;      ;(print "1")
          ;      (setf res (+ res 0)))
          ;     ;CASO 2
          ;     ((and caixa-e-destino?
          ;           (or (ocupada? mapa d)
          ;               (ocupada? mapa u)
          ;               (ocupada? mapa l)
          ;               (ocupada? mapa r)))
          ;      ;(print "2")
          ;      (setf res (+ res 0)))
          ;     ;CASO 3
          ;     ((or (member l destinos :test #'equalp)
          ;          (member r destinos :test #'equalp)
          ;          (member d destinos :test #'equalp)
          ;          (member u destinos :test #'equalp))
          ;      ;(print "3")
          ;      (setf res (+ res 0)))
              ;CASO 4
              ((and (not (ocupada? ocupadas l))
                    (not (ocupada? ocupadas r))
                    (not (ocupada? ocupadas d))
                    (not (ocupada? ocupadas u))
                    (not (ocupada? mapa l))
                    (not (ocupada? mapa r))
                    (not (ocupada? mapa d))
                    (not (ocupada? mapa u)))
               (print "4")
               (setf res (+ res 4)))
              ;CASO 5
              ((or (and (ocupada? mapa l)
                        (not (ocupada? ocupadas r))
                        (not (ocupada? ocupadas d))
                        (not (ocupada? ocupadas u))
                        (not (ocupada? mapa r))
                        (not (ocupada? mapa d))
                        (not (ocupada? mapa u)))
                   (and (ocupada? mapa r)
                        (not (ocupada? ocupadas l))
                        (not (ocupada? ocupadas d))
                        (not (ocupada? ocupadas u))
                        (not (ocupada? mapa l))
                        (not (ocupada? mapa d))
                        (not (ocupada? mapa u)))
                   (and (ocupada? mapa d)
                        (not (ocupada? ocupadas r))
                        (not (ocupada? ocupadas l))
                        (not (ocupada? ocupadas u))
                        (not (ocupada? mapa r))
                        (not (ocupada? mapa l))
                        (not (ocupada? mapa u)))
                   (and (ocupada? mapa u)
                        (not (ocupada? ocupadas r))
                        (not (ocupada? ocupadas d))
                        (not (ocupada? ocupadas l))
                        (not (ocupada? mapa r))
                        (not (ocupada? mapa d))
                        (not (ocupada? mapa l))))
               (print "5")
               (setf res (+ res 8)))
              ;CASO 6
              ((or (and (ocupada? ocupadas l)
                        (not (ocupada? ocupadas r))
                        (not (ocupada? ocupadas d))
                        (not (ocupada? ocupadas u))
                        (not (ocupada? mapa r))
                        (not (ocupada? mapa d))
                        (not (ocupada? mapa u)))
                   (and (ocupada? ocupadas r)
                        (not (ocupada? ocupadas l))
                        (not (ocupada? ocupadas d))
                        (not (ocupada? ocupadas u))
                        (not (ocupada? mapa l))
                        (not (ocupada? mapa d))
                        (not (ocupada? mapa u)))
                   (and (ocupada? ocupadas d)
                        (not (ocupada? ocupadas r))
                        (not (ocupada? ocupadas l))
                        (not (ocupada? ocupadas u))
                        (not (ocupada? mapa r))
                        (not (ocupada? mapa l))
                        (not (ocupada? mapa u)))
                   (and (ocupada? ocupadas u)
                        (not (ocupada? ocupadas r))
                        (not (ocupada? ocupadas d))
                        (not (ocupada? ocupadas l))
                        (not (ocupada? mapa r))
                        (not (ocupada? mapa d))
                        (not (ocupada? mapa l))))
               (print "6")
               (setf res (+ res 8)))
              ;CASO 7
              ((or (and (ocupada? ocupadas u)
                        (or (ocupada? mapa l)
                            (ocupada? mapa r))
                        (not (ocupada? ocupadas d))
                        (not (ocupada? mapa d)))
                   (and (ocupada? ocupadas d)
                        (or (ocupada? mapa l)
                            (ocupada? mapa r))
                        (not (ocupada? ocupadas u))
                        (not (ocupada? mapa u)))
                   (and (ocupada? ocupadas l)
                        (or (ocupada? mapa d)
                            (ocupada? mapa u))
                        (not (ocupada? ocupadas r))
                        (not (ocupada? mapa r)))
                   (and (ocupada? ocupadas r)
                        (or (ocupada? mapa d)
                            (ocupada? mapa u))
                        (not (ocupada? ocupadas l))
                        (not (ocupada? mapa l))))
               (print "7")
               (setf res (+ res 8)))
              ;CASO 8
              ((or (and (ocupada? ocupadas l)
                        (ocupada? ocupadas r)
                        (not (ocupada? ocupadas d))
                        (not (ocupada? ocupadas u))
                        (not (ocupada? mapa d))
                        (not (ocupada? mapa u)))
                   (and (ocupada? ocupadas d)
                        (ocupada? ocupadas u)
                        (not (ocupada? ocupadas l))
                        (not (ocupada? ocupadas r))
                        (not (ocupada? mapa l))
                        (not (ocupada? mapa r))))
               (print "8")
               (setf res (+ res 8)))
              ;CASO 9
              ((or (and (or (and (ocupada? ocupadas l)
                                 (ocupada? mapa r))
                            (and (ocupada? ocupadas r)
                                 (ocupada? mapa l)))
                        (not (ocupada? ocupadas d))
                        (not (ocupada? ocupadas u))
                        (not (ocupada? mapa d))
                        (not (ocupada? mapa u)))
                   (and (or (and (ocupada? ocupadas d)
                                 (ocupada? mapa u))
                            (and (ocupada? ocupadas u)
                                 (ocupada? mapa d)))
                        (not (ocupada? ocupadas l))
                        (not (ocupada? ocupadas r))
                        (not (ocupada? mapa l))
                        (not (ocupada? mapa r))))
               (print "9")
               (setf res (+ res 8)))
              (T 
               (print "LOL")
               (setf res (+ res 9))))))
    (format t "RES: ~d~%" res)
    res))





